# -*- coding: utf-8 -*-
"""plot_likelihoods.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fLYN_G2pPZzZFgzhhqe1382f0eUHyT7h
"""

import numpy as np 
import pandas as pd
import matplotlib.pyplot as plt
from scipy import interpolate
import copy
import sys




def setplot():
    '''Defines standard plot parameters'''
    
    fig = plt.figure(figsize=(3.5, 3), dpi=150)
    ax = plt.gca()
    ax.tick_params(direction='in', which='both', top=True, right=True)
    return ax, fig

def plotTS(summed, masses, sigmav,vmin=0, interp=True,dof=2,
           save=False, filename='TS.png', title=None):

    fig = plt.figure(figsize=(3.5,3),dpi=150)
    fig.gca().patch.set_facecolor('white')
    plt.loglog()
    if interp:

        f = interpolate.RectBivariateSpline(sigmav,masses,summed)

        mass = np.logspace(np.log10(masses.min()),np.log10(masses.max()),num=200,endpoint=True)
        cross = np.logspace(np.log10(sigmav.min()),np.log10(sigmav.max()),num=200,endpoint=True)
        ts = f(cross, mass)
        img = plt.pcolormesh(mass,cross,ts,cmap="inferno",vmin=vmin,vmax=summed.max())
    else:
        img = plt.pcolormesh(masses,sigmav,summed,cmap="inferno",vmin=vmin,vmax=summed.max())

    ind = np.unravel_index(np.argmax(summed,axis=None),summed.shape)


    best_index_value = ind[0]
    best_flux_value = ind[1]

    best_index = sigmav[ind[0]]
    best_flux = masses[ind[1]]

    if(dof!=None):
        if dof==2:
            levels = summed.max() - np.asarray([11.8,6.17,2.3])
        if dof==3:
            levels = summed.max() - np.asarray([14.16, 8.02, 3.53])
        plt.contour(masses,sigmav,summed,levels=levels,colors='limegreen',linestyles=["-.",'--',"-"], linewidths=3*[1],alpha=1)

    plt.plot(best_flux, best_index,marker="+",ms=4,color="black")

    if(title!=None):
        plt.title(title, fontsize=10)
    plt.xlabel('$M_{\chi}$ [GeV]')
    plt.ylabel(r'$\left<\sigma v\right>$ [cm$^{3}$ s$^{-1}$]')
    cbr = plt.colorbar(img, shrink=1)
    cbr.ax.set_title('TS')
    plt.tight_layout()
    
    print(f"Peak TS: {summed.max():.2f}")
    print(f"Peak mass: {best_flux:.3f} GeV")
    print(f"Peak <sigmav> : {best_index} cm^3/s")
    
    if(save):
        plt.savefig(filename)
    else:
    	plt.show()
    	
    return best_index, best_flux, summed.max()


############################################################################################################
#MAIN
############################################################################################################
def main(cmd_line):

	# define 
	mass_vec =  np.logspace(0,4,40)
	sigmav_vec = np.logspace(-28,-22,60)
	summed = 0
	
	#get sources
	srclist = open(cmd_line[1],'r').read().split('\n')
	#protect against empty lines
	if '' in srclist:
		srclist.remove('')
	dsph = True if 'Draco' in srclist else False
	typeStr = "dSph" if dsph else "EG"
	
	for i, srcname in enumerate(srclist):
		# The filename in the load functions need to be your specific numpy arrays for the run
		array_path = homepath+srcname+'/output/dloglike/test/'
		try:
		  like_file = np.load(array_path+'/{}_freeBG_dlike.npy'.format(srcname))
		except:
		  print("{} Does not exist".format())

		# subtracting the like_file[0,0] is to ensure that the 
		# low cross section values have a delta-loglikelihood of 0
		# This is a correction I added since I noticed some targets had an 
		# in the delta-loglikelihood
		# Not sure where this correction comes from, but the correction seems to work
		# Need to talk with Mattia to see if he understands it
		TS_array = 2*(like_file-like_file[0,0])
		
		#Identify lowest value and correct by that, not by the corner entry
		#TS_array = 2*(like_file-like_file.min())
		# the above lines convert the delta log likelihood to TS
		#TS_array = 2*like_file
		
		#print(like_file[0,0])
		#print(TS_array.min())
	
		summed+= TS_array	
		
		#save TS plots for individual inputs
		plotTS(TS_array.T, mass_vec, sigmav_vec, vmin=-50, save=savePlots, filename=homepath+srcname+"/output/plots/TS_"+typeStr+".png", title=srcname)

		
		"""
		TS_vec = np.zeros(len(mass_vec))
		sigmavUL_sims = np.zeros(len(mass_vec))
		likelihood_scan_noprior = summed_noprior
	
		sigmav_scan = sigmav_vec
		sigmavbest_mass = np.zeros(len(mass_vec))
		sigmaverr = np.zeros(len(mass_vec))
	
		for t in range(len(mass_vec)-1):

		  like_zero = likelihood_scan_noprior[t][0]
		  index_max = np.argsort(-likelihood_scan_noprior[t])[0]
		  likelihood_max = likelihood_scan_noprior[t][index_max]
		  TS_vec[t] =  -2.*(like_zero-likelihood_max)
		  try:
			  f_ul = interpolate.interp1d(likelihood_scan_noprior[t][index_max:], sigmav_scan[index_max:], 
										  bounds_error=False, fill_value='extrapolate')

		  except:
			  print('''{} ERROR Prior {:.2f}, {} {}'''.format(srcname, t, sigmav_scan[index_max], index_max))
			  def f_ul(x):
				  return sigmav_scan[index_max]
	  
		  # Here I use 2.71 for the 95% UL, Mattia used 3.84 - but I am not totally sure why
		  # Likely he is not assuming that TS~chi^2 and found the 3.84 another way
		  lim_val = 2.71
		  #lim_val = 3.84

		  if likelihood_max-lim_val > -(likelihood_max-likelihood_scan_noprior[t][index_max:].min()):
			  sigmavUL_sims[t] = f_ul(likelihood_max-lim_val)
		  else:
			  #print('WARNING, extrapolating for m = {:.1f}....'.format(mass_vec[t]))
			  sigmavUL_sims[t] = f_ul(likelihood_max-lim_val)

		  sigmavUL_noprior = copy.deepcopy(sigmavUL_sims)

		  TS_vec = np.zeros(len(mass_vec))
		  sigmavUL_sims = np.zeros(len(mass_vec))
		  likelihood_scan_wprior = summed_wprior
		  sigmavbest_mass = np.zeros(len(mass_vec))
		  sigmaverr = np.zeros(len(mass_vec))
		  for t in range(len(mass_vec)-1):

			  like_zero = likelihood_scan_wprior[t][0]
			  index_max = np.argsort(-likelihood_scan_wprior[t])[0]
			  likelihood_max = likelihood_scan_wprior[t][index_max]
			  TS_vec[t] =  -2.*(like_zero-likelihood_max)
			  try:
				  f_ul = interpolate.interp1d(likelihood_scan_wprior[t][index_max:], sigmav_scan[index_max:], 
											  bounds_error=False, fill_value='extrapolate')
			  except:
				  print('''{} ERROR Prior {:.2f}, {} {}'''.format(srcname, t, sigmav_scan[index_max], index_max))
				  def f_ul(x):
					  return sigmav_scan[index_max]
		  
			  lim_val = 2.71
			  #lim_val = 3.84

			  if likelihood_max-lim_val > -(likelihood_max-likelihood_scan_wprior[t][index_max:].min()):
				  sigmavUL_sims[t] = f_ul(likelihood_max-lim_val)
			  else:
				  #print('WARNING, extrapolating for m = {:.1f}....'.format(mass_vec[t]))
				  sigmavUL_sims[t] = f_ul(likelihood_max-lim_val)

			  like_vecbest = [likelihood_scan_wprior[t][index_max-1],likelihood_scan_wprior[t][index_max],likelihood_scan_wprior[t][index_max]]# removeed the '+1' from index max
			  sigmav_vecbest = [sigmav_scan[index_max-1],sigmav_scan[index_max],sigmav_scan[index_max]]# removeed the '+1' from index max

		  sigmavUL_wprior = copy.deepcopy(sigmavUL_sims)
		"""

	plotTS(summed.T, mass_vec, sigmav_vec, vmin=-3, save=savePlots, filename=homepath+"stack/test/TS_"+typeStr+".png", title="stack_"+typeStr)

	"""
	setplot()
	plt.loglog()
	plt.ylim(1e-28,1e-22)
	plt.xlim(10,1e4)

	plt.plot(mass_vec, sigmavUL_wprior, color='k',   label='w/ Prior')
	plt.plot(mass_vec, sigmavUL_noprior, color='r',   label='no Prior')

	plt.xlabel('$M_{\chi}$ [GeV]')
	plt.ylabel(r'$\left<\sigma v\right>$ [cm$^{3}$ s$^{-1}$]')

	plt.legend(handlelength=0.75, fontsize=8)
	plt.tight_layout()
	
	if savePlots:
		plt.savefig(homepath+'stack/blank_band_comp_'+typeStr+'.png', facecolor='white', transparent=False)
	else:
		plt.show()
	"""


################################################################################################
################################################################################################
################################################################################################
if __name__=="__main__":

	homepath = '/Users/asteinhe/FermiLAT/BHinEGs_DM/run/'
	
	savePlots = False
	
	main(sys.argv)


